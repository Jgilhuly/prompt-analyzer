{
  "recommendations": [
    {
      "type": "Command",
      "name": "move-commits-to-branch",
      "content": "Move the last N commits from the current branch to a new branch. Create a new branch from the current HEAD, reset the current branch to HEAD~N, and checkout the new branch. Preserve all commit messages and changes.",
      "reasoning": "Prompt 14 shows a repeated git workflow pattern: 'move my recent 3 commits to main to a new branch'. This is a common refactoring workflow that benefits from automation."
    },
    {
      "type": "Command",
      "name": "create-branch-and-commit",
      "content": "Create a new git branch from the current branch, stage all changes, commit with a conventional commit message based on the changes, and checkout the new branch. Use conventional commit format: type(scope): description",
      "reasoning": "Prompt 46 shows the pattern 'create a new branch and commit our changes'. This is a frequent workflow that combines multiple git operations."
    },
    {
      "type": "Rule",
      "name": "planning-workflow",
      "content": "When the user asks to 'create a plan', 'plan it out', or 'build me a plan', always create a structured plan document with:\n1. Clear task breakdown with todos\n2. Implementation steps\n3. Dependencies\n4. Testing approach\n\nWhen the user says 'Execute this plan', refer to the most recent plan document and work through todos systematically, marking them as in_progress as you work and completed when done. Do not create new todos if they already exist from the plan.",
      "reasoning": "Prompts 11, 40, 41, 43, 48 show a clear planning workflow pattern: create plan â†’ execute plan. This workflow benefits from consistent structure and execution."
    },
    {
      "type": "Command",
      "name": "create-project-docs",
      "content": "Analyze the current project structure, understand how it works, and create a single markdown file with mermaid diagrams showing:\n1. Project architecture\n2. Data flow\n3. Component relationships\n4. Key workflows\n\nUse dark mode compatible colors for mermaid diagrams. Save the file in .cursor/docs/",
      "reasoning": "Prompts 21 and 38 show repeated requests to 'talk me through this project, and build a single md file with mermaid docs showing how it works'. This is a valuable onboarding/documentation pattern."
    },
    {
      "type": "Command",
      "name": "jira-read-ticket",
      "content": "Read a Jira ticket by ticket key (e.g., KAN-90) from Atlassian Jira, then analyze the codebase and build an implementation plan for the ticket. Include:\n1. Ticket details and requirements\n2. Codebase analysis\n3. Implementation steps\n4. Testing approach",
      "reasoning": "Prompt 20 shows a specific workflow: 'Read ticket KAN-90 from atlassian jira, then analyze our codebase and build a plan'. This combines external tool integration with codebase analysis."
    },
    {
      "type": "Command",
      "name": "jira-update-ticket",
      "content": "Update a Jira ticket status and information to show completion. Include relevant implementation details, links to commits/PRs, and mark appropriate status fields.",
      "reasoning": "Prompt 19 shows the pattern 'Update the jira ticket status and information showing this is complete'. This is a common workflow after completing work."
    },
    {
      "type": "Command",
      "name": "jira-create-demo-tickets",
      "content": "Create demo tickets in Jira with realistic scenarios. Include visual updates that show new features. Generate 5+ tickets with varied complexity and feature types.",
      "reasoning": "Prompts 36 and 37 show requests to create demo tickets in Jira with visual feature updates. This is a testing/demo workflow pattern."
    },
    {
      "type": "Rule",
      "name": "testing-approach",
      "content": "When asked 'how can I easily test this?' or 'test this out in the terminal', provide:\n1. Specific test commands to run\n2. Expected outputs\n3. How to verify the changes work\n4. Edge cases to test\n\nPrefer terminal-based testing when appropriate. Never run dev servers unless explicitly instructed - look for already running servers first.",
      "reasoning": "Prompts 4 and 5 show repeated questions about testing approaches. This pattern benefits from consistent, actionable testing guidance."
    },
    {
      "type": "Rule",
      "name": "debugging-workflow",
      "content": "When debugging issues:\n1. First reproduce the issue and understand the error\n2. Check recent changes that might have caused it\n3. Look at error messages, DOM paths, and stack traces\n4. Test fixes incrementally\n5. Verify the fix doesn't break other functionality\n\nWhen reporting 'it's still not working' or 'still not working', ask for specific error messages, steps to reproduce, and what was expected vs actual behavior.",
      "reasoning": "Prompts 13, 22-35 show extensive debugging workflows with iterative problem-solving. This pattern benefits from structured debugging approach."
    },
    {
      "type": "Rule",
      "name": "filter-boilerplate-prompts",
      "content": "When analyzing prompts, filter out these common boilerplate prompts that don't represent actual user intent:\n1. 'Issue reproduced, please proceed.'\n2. 'The issue has been fixed. Please clean up the instrumentation.'\n3. 'Implement the plan as specified, it is attached for your reference. Do NOT edit the plan file itself. To-do's from the plan have already been created. Do not create them again. Mark them as in_progress as you work, starting with the first one. Don't stop until you have completed all the to-dos.'\n\nThese are workflow instructions, not feature requests or coding tasks.",
      "reasoning": "Prompt 10 explicitly requests filtering out boilerplate prompts. This is important for accurate prompt analysis and prevents noise in recommendations."
    },
    {
      "type": "Rule",
      "name": "styling-improvements",
      "content": "When asked to make 'styling improvements' or 'update the styling':\n1. Use Cursor brand colors (bg: #f7f7f4 light / #14120b dark, accent: #f54e00, card variants)\n2. Prefer dark mode compatible colors by default\n3. Create modern, professional layouts\n4. Use tabbed views for organizing content when appropriate\n5. Include deeplinks for Cursor integrations when relevant",
      "reasoning": "Prompts 3 and 42 show styling improvement requests with specific requirements (tabs, deeplinks, modern layouts). This benefits from consistent styling guidelines."
    },
    {
      "type": "Rule",
      "name": "feature-gap-identification",
      "content": "When a user identifies a missing feature or gap (e.g., 'It looks like we're missing a way to...'), first:\n1. Confirm the gap exists\n2. Analyze the codebase to understand current capabilities\n3. Propose a solution that fits the existing architecture\n4. Consider data sources and integration points\n5. Build a plan before implementing",
      "reasoning": "Prompts 44 and 45 show feature gap identification patterns. This workflow benefits from systematic analysis before implementation."
    },
    {
      "type": "Rule",
      "name": "data-integration",
      "content": "When asked to 'connect to actual sources' instead of mock data:\n1. Identify appropriate public APIs or data sources\n2. Use httpx library for Python projects (never requests)\n3. Handle API rate limits and errors gracefully\n4. Cache data appropriately\n5. Maintain backward compatibility with existing code",
      "reasoning": "Prompt 47 shows a pattern of replacing mock data with real sources. This benefits from consistent integration practices."
    },
    {
      "type": "Rule",
      "name": "customer-support-debugging",
      "content": "When debugging customer-reported issues:\n1. Reproduce the issue in the described environment\n2. Check for known issues or similar reports\n3. Look for system-level problems (e.g., 'OSError: out of pty devices')\n4. Provide workarounds if available\n5. Document the root cause and solution\n\nFor system-level errors, check resource limits, file descriptors, and system configuration.",
      "reasoning": "Prompt 50 shows customer support debugging pattern. This requires systematic investigation and clear communication."
    },
    {
      "type": "Command",
      "name": "scan-cursor-config",
      "content": "Scan for existing Cursor rules and commands in:\n1. Current project: .cursor/rules and .cursor/commands\n2. User global: ~/.cursor/rules and ~/.cursor/commands\n\nReturn a list of existing rules and commands with their scope (project vs user) and content preview.",
      "reasoning": "Prompts 2 and 8 show the need to scan for existing Cursor configuration. This is essential for avoiding duplicates and understanding existing setup."
    }
  ]
}
