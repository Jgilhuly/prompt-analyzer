"""Hook script generator and templates."""

import json
from pathlib import Path
from typing import Optional

from ..storage.paths import get_database_path


HOOK_SCRIPT_TEMPLATE = """// Prompt Analyzer Hook Script
// Auto-generated by prompt-analyzer setup command
// This script captures prompts and responses from Cursor and writes them to SQLite

const crypto = require('crypto');

// UUID v4 generator using built-in crypto
function uuidv4() {
  return crypto.randomUUID ? crypto.randomUUID() : 
    'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
}

// Load better-sqlite3 (synchronous SQLite library)
let Database;
try {
  Database = require('better-sqlite3');
} catch (e) {
  console.error('[prompt-analyzer] better-sqlite3 not found. Please install: npm install better-sqlite3');
  console.error('[prompt-analyzer] Error:', e.message);
  process.exit(1);
}

const DB_PATH = '{{DB_PATH}}';

// Initialize database connection
let db;
try {
  db = new Database(DB_PATH);
  db.pragma('journal_mode = WAL');
  db.pragma('foreign_keys = ON');
  
  // Ensure table exists
  db.exec(`
    CREATE TABLE IF NOT EXISTS prompts (
      id TEXT PRIMARY KEY,
      timestamp TEXT NOT NULL,
      prompt_text TEXT NOT NULL,
      response_text TEXT,
      user_action TEXT CHECK(user_action IN ('accepted', 'rejected', 'edited') OR user_action IS NULL),
      session_id TEXT NOT NULL,
      sequence_number INTEGER NOT NULL,
      analysis_score INTEGER CHECK(analysis_score >= 0 AND analysis_score <= 100),
      analysis_flags TEXT,
      analysis_suggestions TEXT,
      analysis_is_repeated INTEGER DEFAULT 0,
      analysis_repeated_with TEXT,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )
  `);
  
  // Create indexes
  db.exec(`
    CREATE INDEX IF NOT EXISTS idx_timestamp ON prompts(timestamp);
    CREATE INDEX IF NOT EXISTS idx_session_id ON prompts(session_id);
    CREATE INDEX IF NOT EXISTS idx_user_action ON prompts(user_action);
    CREATE INDEX IF NOT EXISTS idx_analysis_score ON prompts(analysis_score);
  `);
} catch (error) {
  console.error('[prompt-analyzer] Failed to initialize database:', error.message);
  process.exit(1);
}

// Session tracking: map conversation_id to session metadata
const sessionCache = new Map();

function getSessionSequence(conversationId) {
  if (!sessionCache.has(conversationId)) {
    // Get max sequence number for this session
    try {
      const stmt = db.prepare('SELECT MAX(sequence_number) as max_seq FROM prompts WHERE session_id = ?');
      const result = stmt.get(conversationId);
      const maxSeq = result ? (result.max_seq || 0) : 0;
      sessionCache.set(conversationId, { sequence: maxSeq });
    } catch (error) {
      // If query fails, start from 0
      sessionCache.set(conversationId, { sequence: 0 });
    }
  }
  const session = sessionCache.get(conversationId);
  session.sequence += 1;
  return session.sequence;
}

function insertPrompt(data) {
  try {
    const {
      conversation_id,
      generation_id,
      hook_event_name,
      prompt_text,
      response_text,
      user_action
    } = data;

    // Use conversation_id as session_id
    const sessionId = conversation_id || uuidv4();
    const sequenceNumber = getSessionSequence(sessionId);
    const promptId = uuidv4();
    const timestamp = new Date().toISOString();

    const insert = db.prepare(`
      INSERT INTO prompts (
        id, timestamp, prompt_text, response_text, user_action,
        session_id, sequence_number
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `);

    insert.run(
      promptId,
      timestamp,
      prompt_text || '',
      response_text || null,
      user_action || null,
      sessionId,
      sequenceNumber
    );

    return { success: true, promptId };
  } catch (error) {
    console.error('[prompt-analyzer] Failed to insert prompt:', error.message);
    return { success: false, error: error.message };
  }
}

function updatePromptAction(promptId, userAction) {
  try {
    const update = db.prepare('UPDATE prompts SET user_action = ? WHERE id = ?');
    update.run(userAction, promptId);
    return { success: true };
  } catch (error) {
    console.error('[prompt-analyzer] Failed to update prompt action:', error.message);
    return { success: false, error: error.message };
  }
}

// Main hook handler
function handleHook(input) {
  try {
    const {
      conversation_id,
      generation_id,
      hook_event_name,
      workspace_roots
    } = input;

    // Handle different hook event types
    switch (hook_event_name) {
      case 'composer.prompt.submitted':
      case 'composer.prompt.sent':
        // Extract prompt text from input
        const promptText = input.prompt_text || input.message || JSON.stringify(input);
        insertPrompt({
          conversation_id,
          generation_id,
          hook_event_name,
          prompt_text: promptText,
          user_action: null
        });
        break;

      case 'composer.response.received':
      case 'composer.response.generated':
        // Extract response text
        const responseText = input.response_text || input.response || input.content || JSON.stringify(input);
        // Try to find the corresponding prompt by generation_id or conversation_id
        const updateResponse = db.prepare(`
          UPDATE prompts 
          SET response_text = ? 
          WHERE session_id = ? AND response_text IS NULL 
          ORDER BY sequence_number DESC LIMIT 1
        `);
        updateResponse.run(responseText, conversation_id);
        break;

      case 'composer.response.accepted':
      case 'composer.suggestion.accepted':
        updatePromptAction(generation_id, 'accepted');
        break;

      case 'composer.response.rejected':
      case 'composer.suggestion.rejected':
        updatePromptAction(generation_id, 'rejected');
        break;

      case 'composer.response.edited':
      case 'composer.suggestion.edited':
        updatePromptAction(generation_id, 'edited');
        break;

      default:
        // Fallback: try to extract prompt/response from any event
        if (input.prompt_text || input.message) {
          insertPrompt({
            conversation_id,
            generation_id,
            hook_event_name,
            prompt_text: input.prompt_text || input.message,
            response_text: input.response_text || input.response || null,
            user_action: input.user_action || null
          });
        }
        break;
    }

    return { success: true };
  } catch (error) {
    console.error('[prompt-analyzer] Hook error:', error.message);
    return { success: false, error: error.message };
  }
}

// Process hook input from stdin
if (require.main === module) {
  let inputData = '';
  process.stdin.setEncoding('utf8');
  
  process.stdin.on('data', (chunk) => {
    inputData += chunk;
  });
  
  process.stdin.on('end', () => {
    try {
      const input = JSON.parse(inputData);
      const result = handleHook(input);
      process.stdout.write(JSON.stringify(result));
      process.exit(result.success ? 0 : 1);
    } catch (error) {
      console.error('[prompt-analyzer] Parse error:', error.message);
      process.exit(1);
    }
  });
}

module.exports = { handleHook, insertPrompt, updatePromptAction };
"""


def generate_hook_script(db_path: Optional[Path] = None) -> str:
    """Generate the hook script with database path filled in."""
    if db_path is None:
        db_path = get_database_path()
    
    # Convert to absolute path and escape backslashes for JavaScript
    abs_path = str(db_path.expanduser().resolve()).replace('\\', '\\\\')
    
    script = HOOK_SCRIPT_TEMPLATE.replace('{{DB_PATH}}', abs_path)
    return script


def get_hooks_json_content(hook_script_path: Path) -> dict:
    """Generate hooks.json content."""
    # Convert to relative path from ~/.cursor/ if possible, otherwise use absolute
    script_path_str = str(hook_script_path)
    
    return {
        "hooks": [
            {
                "hook": script_path_str,
                "events": [
                    "composer.prompt.submitted",
                    "composer.prompt.sent",
                    "composer.response.received",
                    "composer.response.generated",
                    "composer.response.accepted",
                    "composer.response.rejected",
                    "composer.response.edited",
                    "composer.suggestion.accepted",
                    "composer.suggestion.rejected",
                    "composer.suggestion.edited"
                ]
            }
        ]
    }

